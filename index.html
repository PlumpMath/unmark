<head><link href="tufte-css/tufte.css" rel="stylesheet" /></head><body><div><h1>Lazy Physics</h1><p><em>... in which we explore lazy sequences and common
     functional idioms in Clojure via the example of looking for
     (nearly-)coincident clusters of times in a series.</em></p><p>A fundamental technical problem in experimental particle physics
     is how to distinguish the signatures of particles from
     instrumental noise.</p><p><a href="img/birds-on-wires.jpg"><img src="img/birds-on-wires.jpg" /></a></p><p><span>Imagine a tree full of hundreds of sparrows, each nesting
     on a branch, each chirping away occasionally. Suddenly, for a
     brief moment, they all start chirping vigorously (maybe a hawk
     flew past). A clustering of chirps in time is the signal that <span><em>something has happened!</em> The analogous situation occurs
     in instruments consisting of many similar detector elements, each
     generating some amount of random noise that, on its own, is
     indistinguishable from any evidence left by particles, but which,
     taken together, signals that, again, <em>something has
     happened</em> - a muon, an electron, a neutrino has left a sudden
     spume of electronic evidence in your instrument, waiting to be
     read out and distinguished from the endless noise.</span></span></p><p><span>This process of separating the noise from the signal is
     known in physics as <em>triggering</em> and is typically done
     through some combination of spatial or time clustering; in many
     cases, time is the simplest to handle and the first "line of
     defense" against being overrun by too much data. (It is often
     impractical to consume all the data generated by all the elements
     - data reduction is the name of the game at most stages of these
     experiments.)</span></p><p><span>This data is typically generated
     continously <em>ad infinitum</em>, and must therefore be processed
     differently than, say, a single file on disk. Such infinite
     sequences of data are an excellent fit for the functional pattern
     known as <em>laziness</em>, in which, rather than chewing up all
     your RAM and/or hard disk space, data is consumed and transformed
     only as needed / as available. This kind of processing is baked
     into Clojure at many levels and throughout its library of core
     functions, dozens of which can be combined ("composed") to
     serve an endless variety of data transformations. (This style of
     data wrangling is also available in Python via generators and
     functional libraries such as <a href="http://toolz.readthedocs.org/">Toolz</a>.)</span></p><p>Prompted by a recent question on the topic from a physicist and
     former colleague, I got to thinking about the classic problem of
     triggering, and realized that the time series trigger provides a
     nice showcase for Clojure&rsquo;s core library and for processing lazy
     sequences. The rest of this post will describe a simple trigger,
     essentially what particle astrophysicists I know call a "simple
     majority trigger"; or a "simple multiplicity trigger" (depending
     on whom you talk to).</p><p><span>Now for some Clojure code. (A small amount of familiarity with
     Clojure&rsquo;s simple syntax is recommended for maximum understanding
     of what follows.) We will build up our understanding through a
     series of successively more complex code snippets. The exposition
     follows closely what one might do in the Clojure REPL, building
     up successively more complete examples. In each case, we use <code>take</code> to limit what would otherwise be infinite
     sequences of data (so that our examples can terminate without
     keeping us waiting
     forever...).</span></p><p>First we create a sorted, infinite series of ever-increasing
     times (in, say, nsec):</p><p><pre><code>(def times (iterate #(+ % (rand-int 1000)) 0))
;; Caution: infinite sequence...

(take 30 times)

;;=>
(0 955 1559 2063 2735 2858 3542 4067 4366 5246 5430 6168 7127 7932
 8268 8929 9426 9918 10436 10850 11680 12367 12569 13343 14155 14420
 15062 15171 15663 16355)
</code></pre></p><p><span><code>times</code> is an infinite (but &ldquo;unrealized&rdquo;) series, constructed by
     iterating the anonymous function <code>#(+ % (rand-int 1000))</code> which
     adds a random integer from 0 to 999 to its argument (starting
     with zero). The fact that it is infinite does not prevent us from
     defining it or (gingerly) interrogating it via <code>take</code>.<span><label class="margin-toggle sidenote-number" for="G__22642"></label><input class="margin-toggle" id="G__22642" type="checkbox" /><span class="sidenote"><span>To model a <a href="http://en.wikipedia.org/wiki/Poisson_process">Poisson</a> process &mdash; one in which any given event time is independent of
      the future or past times &mdash; one would normally choose an
      exponential rather than a uniformly flat distribution of time
      differences, but this is not important for our discussion, so, in
      the interest of simplicity, we&rsquo;ll go with what we have
      here.</span></span></span></span></p><p><span>Now, the way we&rsquo;ll look for excesses is to look for
     groupings of hits (say, eight of them) whose first and last hit
     times are within 1 microsecond (1000 nsec) of each other. To start,
     there is a handy function called <code>partition</code> which
     groups a series in blocks of fixed length:</span></p><p><pre><code>(take 10 (partition 8 times))

;;=>
((0 955 1559 2063 2735 2858 3542 4067)
 (4366 5246 5430 6168 7127 7932 8268 8929)
 (9426 9918 10436 10850 11680 12367 12569 13343)
 (14155 14420 15062 15171 15663 16355 16700 16947)
 (17919 17949 18575 18607 18849 19597 20410 20680)
 (20737 21289 21315 21323 21426 21637 22422 23000)
 (23477 24351 24426 25106 25861 26568 27511 28332)
 (29071 29831 29957 30761 31073 31914 32591 33187)
 (33878 34739 34842 35674 36444 36960 36983 37400)
 (37587 38012 38969 39131 39317 40135 40587 40759))</code></pre></p><p>We&rsquo;ll rewrite this using Clojure&rsquo;s thread-last macro, which is a
     very helpful tool for rewriting nested expressions as a more
     readable pipeline of successive function applications:</p><p><pre><code>(->> times
     (partition 8)
     (take 10))

;;=>
((0 955 1559 2063 2735 2858 3542 4067)
 (4366 5246 5430 6168 7127 7932 8268 8929)
 ...same as above...)</code></pre></p><p><span>However, this isn&rsquo;t quite what we want, because it won&rsquo;t
     find clusters of times close together who don&rsquo;t happen to begin
     on our <code>partition</code> boundaries. To fix this, we use
     the optional <code>step</code> argument to <code>partition</code>:</span></p><p><pre><code>(->> times
     (partition 8 1)
     (take 10))

;;=>
((0 955 1559 2063 2735 2858 3542 4067)
 (955 1559 2063 2735 2858 3542 4067 4366)
 (1559 2063 2735 2858 3542 4067 4366 5246)
 (2063 2735 2858 3542 4067 4366 5246 5430)
 (2735 2858 3542 4067 4366 5246 5430 6168)
 (2858 3542 4067 4366 5246 5430 6168 7127)
 (3542 4067 4366 5246 5430 6168 7127 7932)
 (4067 4366 5246 5430 6168 7127 7932 8268)
 (4366 5246 5430 6168 7127 7932 8268 8929)
 (5246 5430 6168 7127 7932 8268 8929 9426))</code></pre></p><p><span>This is getting closer to what we want&mdash;if you look
     carefully, you&rsquo;ll see that each row consists of the previous one
     shifted by one element. The next step is to grab (via <code>map</code>)
     the first and last times of each group, using <code>juxt</code> to apply
     both <code>first</code> and <code>last</code> to each subsequence&hellip;</span></p><p><pre><code>(->> times
     (partition 8 1)
     (map (juxt last first))
     (take 10))

;;=>
([4067 0]
 [4366 955]
 [5246 1559]
 [5430 2063]
 [6168 2735]
 [7127 2858]
 [7932 3542]
 [8268 4067]
 [8929 4366]
 [9426 5246])</code></pre></p><p>&hellip; and turn these into time differences:</p><p><pre><code>(->> times
     (partition 8 1)
     (map (comp (partial apply -) (juxt last first)))
     (take 10))

;;=>
(4067 3411 3687 3367 3433 4269 4390 4201 4563 4180)
</code></pre></p><p><span>Note that so far these time differences are all > 1000. <code>comp</code>, above, turns a collection of multiple
      functions into a new function which is the composition of these
      functions, applied successively one after the other
      (right-to-left). <code>partial</code> turns a function of
      multiple arguments into a function of fewer arguments, by
      binding one or more of the arguments in a new function. For
      example,</span></p><p><pre><code>((partial + 2) 3)

;;=>
5

((comp (partial apply -) (juxt last first)) [3 10])

;;=>
7</code></pre></p><p><span>Recall that we only want events whose times are close to
     each other; say, whose duration is under a maximum limit of 1000
     nsec. In general, to select only the elements of a sequence which
     satisfy a filter function, we use <code>filter</code>:</span></p><p><pre><code>(->> times
     (partition 8 1)
     (map (comp (partial apply -) (juxt last first)))
     (filter (partial > 1000))
     (take 10))

;;=>
(960 942 827 763 597 682 997 836 986 966)</code></pre></p><p><span>(<code>(partial > 1000)</code> is a function of one
     argument which returns true if that argument is strictly less
     than 1000.)</span></p><p>Great! We now have total &ldquo;durations&rdquo;; for subsequences of 8
     times, where the total durations are less than 1000 nsec.</p><p>But this is not actually that helpful. It would be better if we
     could get both the total durations and the actual subsequences
     satisfying the requirement (the analog of this in a real physics
     experiment would be returning the actual hit data falling inside
     the trigger window).</p><p><span>To do this, <code>juxt</code> once again comes to the
     rescue, by allowing us to juxt-apose the original data along side
     the total duration to show both together&hellip;</span></p></div><div><h1>Working with Me</h1><p><div class="epigraph"><blockquote>Great things are done by a series of small things brought together.<footer>Vincent Van Gogh</footer></blockquote></div></p><p><h2>Practices I Like</h2><p><h3>"Test First"</h3></p><p><h3>Promiscuous pairing</h3><p>...</p></p></p><p><h2>Tools I Use</h2><p><h3>Clojure</h3><p>...</p></p><p><h3>Emacs</h3></p></p><p><h2>Technical Strengths</h2><p><ul><li>Debugging</li></ul></p><p>...</p></p></div></body><p>Created with <a href="https://github.com/eigenhombre/unmark">unmark</a>.  CSS by <a href="https://edwardtufte.github.io/tufte-css/">Tufte-CSS</a>.</p>